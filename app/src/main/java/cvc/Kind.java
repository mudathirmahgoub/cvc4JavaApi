package cvc;

import java.util.HashMap;
import java.util.Map;

public enum Kind {
  INTERNAL_KIND(-2),
  UNDEFINED_KIND(-1),
  NULL_EXPR(0),
  UNINTERPRETED_CONSTANT(1),
  ABSTRACT_VALUE(2),
  EQUAL(3),
  DISTINCT(4),
  CONSTANT(5),
  VARIABLE(6),
  SEXPR(7),
  LAMBDA(8),
  WITNESS(9),
  CONST_BOOLEAN(10),
  NOT(11),
  AND(12),
  IMPLIES(13),
  OR(14),
  XOR(15),
  ITE(16),
  APPLY_UF(17),
  CARDINALITY_CONSTRAINT(18),
  CARDINALITY_VALUE(19),
  HO_APPLY(20),
  PLUS(21),
  MULT(22),
  IAND(23),
  MINUS(24),
  UMINUS(25),
  DIVISION(26),
  INTS_DIVISION(27),
  INTS_MODULUS(28),
  ABS(29),
  POW(30),
  EXPONENTIAL(31),
  SINE(32),
  COSINE(33),
  TANGENT(34),
  COSECANT(35),
  SECANT(36),
  COTANGENT(37),
  ARCSINE(38),
  ARCCOSINE(39),
  ARCTANGENT(40),
  ARCCOSECANT(41),
  ARCSECANT(42),
  ARCCOTANGENT(43),
  SQRT(44),
  DIVISIBLE(45),
  CONST_RATIONAL(46),
  LT(47),
  LEQ(48),
  GT(49),
  GEQ(50),
  IS_INTEGER(51),
  TO_INTEGER(52),
  TO_REAL(53),
  PI(54),
  CONST_BITVECTOR(55),
  BITVECTOR_CONCAT(56),
  BITVECTOR_AND(57),
  BITVECTOR_OR(58),
  BITVECTOR_XOR(59),
  BITVECTOR_NOT(60),
  BITVECTOR_NAND(61),
  BITVECTOR_NOR(62),
  BITVECTOR_XNOR(63),
  BITVECTOR_COMP(64),
  BITVECTOR_MULT(65),
  BITVECTOR_PLUS(66),
  BITVECTOR_SUB(67),
  BITVECTOR_NEG(68),
  BITVECTOR_UDIV(69),
  BITVECTOR_UREM(70),
  BITVECTOR_SDIV(71),
  BITVECTOR_SREM(72),
  BITVECTOR_SMOD(73),
  BITVECTOR_SHL(74),
  BITVECTOR_LSHR(75),
  BITVECTOR_ASHR(76),
  BITVECTOR_ULT(77),
  BITVECTOR_ULE(78),
  BITVECTOR_UGT(79),
  BITVECTOR_UGE(80),
  BITVECTOR_SLT(81),
  BITVECTOR_SLE(82),
  BITVECTOR_SGT(83),
  BITVECTOR_SGE(84),
  BITVECTOR_ULTBV(85),
  BITVECTOR_SLTBV(86),
  BITVECTOR_ITE(87),
  BITVECTOR_REDOR(88),
  BITVECTOR_REDAND(89),
  BITVECTOR_EXTRACT(90),
  BITVECTOR_REPEAT(91),
  BITVECTOR_ZERO_EXTEND(92),
  BITVECTOR_SIGN_EXTEND(93),
  BITVECTOR_ROTATE_LEFT(94),
  BITVECTOR_ROTATE_RIGHT(95),
  INT_TO_BITVECTOR(96),
  BITVECTOR_TO_NAT(97),
  CONST_FLOATINGPOINT(98),
  CONST_ROUNDINGMODE(99),
  FLOATINGPOINT_FP(100),
  FLOATINGPOINT_EQ(101),
  FLOATINGPOINT_ABS(102),
  FLOATINGPOINT_NEG(103),
  FLOATINGPOINT_PLUS(104),
  FLOATINGPOINT_SUB(105),
  FLOATINGPOINT_MULT(106),
  FLOATINGPOINT_DIV(107),
  FLOATINGPOINT_FMA(108),
  FLOATINGPOINT_SQRT(109),
  FLOATINGPOINT_REM(110),
  FLOATINGPOINT_RTI(111),
  FLOATINGPOINT_MIN(112),
  FLOATINGPOINT_MAX(113),
  FLOATINGPOINT_LEQ(114),
  FLOATINGPOINT_LT(115),
  FLOATINGPOINT_GEQ(116),
  FLOATINGPOINT_GT(117),
  FLOATINGPOINT_ISN(118),
  FLOATINGPOINT_ISSN(119),
  FLOATINGPOINT_ISZ(120),
  FLOATINGPOINT_ISINF(121),
  FLOATINGPOINT_ISNAN(122),
  FLOATINGPOINT_ISNEG(123),
  FLOATINGPOINT_ISPOS(124),
  FLOATINGPOINT_TO_FP_IEEE_BITVECTOR(125),
  FLOATINGPOINT_TO_FP_FLOATINGPOINT(126),
  FLOATINGPOINT_TO_FP_REAL(127),
  FLOATINGPOINT_TO_FP_SIGNED_BITVECTOR(128),
  FLOATINGPOINT_TO_FP_UNSIGNED_BITVECTOR(129),
  FLOATINGPOINT_TO_FP_GENERIC(130),
  FLOATINGPOINT_TO_UBV(131),
  FLOATINGPOINT_TO_SBV(132),
  FLOATINGPOINT_TO_REAL(133),
  SELECT(134),
  STORE(135),
  CONST_ARRAY(136),
  EQ_RANGE(137),
  APPLY_CONSTRUCTOR(138),
  APPLY_SELECTOR(139),
  APPLY_TESTER(140),
  TUPLE_UPDATE(141),
  RECORD_UPDATE(142),
  MATCH(143),
  MATCH_CASE(144),
  MATCH_BIND_CASE(145),
  DT_SIZE(146),
  TUPLE_PROJECT(147),
  SEP_NIL(148),
  SEP_EMP(149),
  SEP_PTO(150),
  SEP_STAR(151),
  SEP_WAND(152),
  EMPTYSET(153),
  UNION(154),
  INTERSECTION(155),
  SETMINUS(156),
  SUBSET(157),
  MEMBER(158),
  SINGLETON(159),
  INSERT(160),
  CARD(161),
  COMPLEMENT(162),
  UNIVERSE_SET(163),
  JOIN(164),
  PRODUCT(165),
  TRANSPOSE(166),
  TCLOSURE(167),
  JOIN_IMAGE(168),
  IDEN(169),
  COMPREHENSION(170),
  CHOOSE(171),
  IS_SINGLETON(172),
  EMPTYBAG(173),
  UNION_MAX(174),
  UNION_DISJOINT(175),
  INTERSECTION_MIN(176),
  DIFFERENCE_SUBTRACT(177),
  DIFFERENCE_REMOVE(178),
  SUBBAG(179),
  BAG_COUNT(180),
  DUPLICATE_REMOVAL(181),
  MK_BAG(182),
  BAG_CARD(183),
  BAG_CHOOSE(184),
  BAG_IS_SINGLETON(185),
  BAG_FROM_SET(186),
  BAG_TO_SET(187),
  STRING_CONCAT(188),
  STRING_IN_REGEXP(189),
  STRING_LENGTH(190),
  STRING_SUBSTR(191),
  STRING_UPDATE(192),
  STRING_CHARAT(193),
  STRING_CONTAINS(194),
  STRING_INDEXOF(195),
  STRING_REPLACE(196),
  STRING_REPLACE_ALL(197),
  STRING_REPLACE_RE(198),
  STRING_REPLACE_RE_ALL(199),
  STRING_TOLOWER(200),
  STRING_TOUPPER(201),
  STRING_REV(202),
  STRING_TO_CODE(203),
  STRING_FROM_CODE(204),
  STRING_LT(205),
  STRING_LEQ(206),
  STRING_PREFIX(207),
  STRING_SUFFIX(208),
  STRING_IS_DIGIT(209),
  STRING_FROM_INT(210),
  STRING_TO_INT(211),
  CONST_STRING(212),
  STRING_TO_REGEXP(213),
  REGEXP_CONCAT(214),
  REGEXP_UNION(215),
  REGEXP_INTER(216),
  REGEXP_DIFF(217),
  REGEXP_STAR(218),
  REGEXP_PLUS(219),
  REGEXP_OPT(220),
  REGEXP_RANGE(221),
  REGEXP_REPEAT(222),
  REGEXP_LOOP(223),
  REGEXP_EMPTY(224),
  REGEXP_SIGMA(225),
  REGEXP_COMPLEMENT(226),
  SEQ_CONCAT(227),
  SEQ_LENGTH(228),
  SEQ_EXTRACT(229),
  SEQ_UPDATE(230),
  SEQ_AT(231),
  SEQ_CONTAINS(232),
  SEQ_INDEXOF(233),
  SEQ_REPLACE(234),
  SEQ_REPLACE_ALL(235),
  SEQ_REV(236),
  SEQ_PREFIX(237),
  SEQ_SUFFIX(238),
  CONST_SEQUENCE(239),
  SEQ_UNIT(240),
  SEQ_NTH(241),
  FORALL(242),
  EXISTS(243),
  BOUND_VAR_LIST(244),
  INST_PATTERN(245),
  INST_NO_PATTERN(246),
  INST_ATTRIBUTE(247),
  INST_PATTERN_LIST(248),
  LAST_KIND(249),
  ;

  /* the int value of the kind*/
  private int value;
  private static Map<Integer, Kind> kindMap = new HashMap<>();
  private Kind(int value)
  {
    this.value = value;
  }

  static
  {
    for (Kind kind : Kind.values())
    {
      kindMap.put(kind.getValue(), kind);
    }
  }

  public static Kind fromInt(int value) throws CVCApiException
  {
    if (value < INTERNAL_KIND.value || value > LAST_KIND.value)
    {
      throw new CVCApiException("Kind value " + value + " is outside the valid range ["
          + INTERNAL_KIND.value + "," + LAST_KIND.value + "]");
    }
    return kindMap.get(value);
  }

  public int getValue()
  {
    return value;
  }
}
