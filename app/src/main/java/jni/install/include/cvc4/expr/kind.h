/*********************                                                        */
/** kind.h
 **
 ** Copyright 2010-2014  New York University and The University of Iowa,
 ** and as below.
 **
 ** This header file automatically generated by:
 **
 **     ../../../src/expr/mkkind /home/mudathir/Desktop/CVC4/java/src/expr/kind_template.h /home/mudathir/Desktop/CVC4/java/src/theory/builtin/kinds /home/mudathir/Desktop/CVC4/java/src/theory/booleans/kinds /home/mudathir/Desktop/CVC4/java/src/theory/uf/kinds /home/mudathir/Desktop/CVC4/java/src/theory/arith/kinds /home/mudathir/Desktop/CVC4/java/src/theory/bv/kinds /home/mudathir/Desktop/CVC4/java/src/theory/fp/kinds /home/mudathir/Desktop/CVC4/java/src/theory/arrays/kinds /home/mudathir/Desktop/CVC4/java/src/theory/datatypes/kinds /home/mudathir/Desktop/CVC4/java/src/theory/sep/kinds /home/mudathir/Desktop/CVC4/java/src/theory/sets/kinds /home/mudathir/Desktop/CVC4/java/src/theory/bags/kinds /home/mudathir/Desktop/CVC4/java/src/theory/strings/kinds /home/mudathir/Desktop/CVC4/java/src/theory/quantifiers/kinds
 **
 ** for the CVC4 project.
 **/

/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */

/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */

/* Edit the template file instead:                     */
/* /home/mudathir/Desktop/CVC4/java/src/expr/kind_template.h */

/*********************                                                        */
/*! \file kind_template.h
 ** \verbatim
 ** Top contributors (to current version):
 **   Andres Noetzli, Morgan Deters, Dejan Jovanovic
 ** This file is part of the CVC4 project.
 ** Copyright (c) 2009-2021 by the authors listed in the file AUTHORS
 ** in the top-level source directory and their institutional affiliations.
 ** All rights reserved.  See the file COPYING in the top-level source
 ** directory for licensing information.\endverbatim
 **
 ** \brief Template for the Node kind header
 **
 ** Template for the Node kind header.
 **/

#include <cvc4/cvc4_public.h>

#ifndef CVC4__KIND_H
#define CVC4__KIND_H

#include <iosfwd>

#include <cvc4/base/exception.h>
#include <cvc4/theory/theory_id.h>

namespace CVC4 {
namespace kind {

enum CVC4_PUBLIC Kind_t {
  UNDEFINED_KIND = -1, /**< undefined */
  NULL_EXPR, /**< Null kind */

  /* from builtin */
  SORT_TAG, /**< sort tag (1) */
  SORT_TYPE, /**< specifies types of user-declared 'uninterpreted' sorts (2) */
  UNINTERPRETED_CONSTANT, /**< the kind of expressions representing uninterpreted constants; payload is an instance of the CVC4::UninterpretedConstant class (used in models) (3) */
  ABSTRACT_VALUE, /**< the kind of expressions representing abstract values (other than uninterpreted sort constants); payload is an instance of the CVC4::AbstractValue class (used in models) (4) */
  BUILTIN, /**< the kind of expressions representing built-in operators (5) */
  EQUAL, /**< equality (two parameters only, sorts must match) (6) */
  DISTINCT, /**< disequality (N-ary, sorts must match) (7) */
  VARIABLE, /**< a variable (not permitted in bindings) (8) */
  BOUND_VARIABLE, /**< a bound variable (permitted in bindings and the associated lambda and quantifier bodies only) (9) */
  SKOLEM, /**< a Skolem variable (internal only) (10) */
  SEXPR, /**< a symbolic expression (any arity) (11) */
  LAMBDA, /**< a lambda expression; first parameter is a BOUND_VAR_LIST, second is lambda body (12) */
  WITNESS, /**< a witness expression; first parameter is a BOUND_VAR_LIST, second is the witness body (13) */
  TYPE_CONSTANT, /**< a representation for basic types (14) */
  FUNCTION_TYPE, /**< a function type (15) */
  SEXPR_TYPE, /**< the type of a symbolic expression (16) */

  /* from booleans */
  CONST_BOOLEAN, /**< truth and falsity; payload is a (C++) bool (17) */
  NOT, /**< logical not (18) */
  AND, /**< logical and (N-ary) (19) */
  IMPLIES, /**< logical implication (exactly two parameters) (20) */
  OR, /**< logical or (N-ary) (21) */
  XOR, /**< exclusive or (exactly two parameters) (22) */
  ITE, /**< if-then-else, used for both Boolean and term ITE constructs; first parameter is (Boolean-sorted) condition, second is 'then', third is 'else' and these two parameters must have same base sort (23) */

  /* from uf */
  APPLY_UF, /**< application of an uninterpreted function; first parameter is the function, remaining ones are parameters to that function (24) */
  BOOLEAN_TERM_VARIABLE, /**< Boolean term variable (25) */
  CARDINALITY_CONSTRAINT, /**< cardinality constraint on sort S: first parameter is (any) term of sort S, second is a positive integer constant k that bounds the cardinality of S (26) */
  COMBINED_CARDINALITY_CONSTRAINT, /**< combined cardinality constraint; parameter is a positive integer constant k that bounds the sum of the cardinalities of all sorts in the signature (27) */
  PARTIAL_APPLY_UF, /**< partial uninterpreted function application (28) */
  CARDINALITY_VALUE, /**< cardinality value of sort S: first parameter is (any) term of sort S (29) */
  HO_APPLY, /**< higher-order (partial) function application (30) */

  /* from arith */
  PLUS, /**< arithmetic addition (N-ary) (31) */
  MULT, /**< arithmetic multiplication (N-ary) (32) */
  NONLINEAR_MULT, /**< synonym for MULT (33) */
  MINUS, /**< arithmetic binary subtraction operator (34) */
  UMINUS, /**< arithmetic unary negation (35) */
  DIVISION, /**< real division, division by 0 undefined (user symbol) (36) */
  DIVISION_TOTAL, /**< real division with interpreted division by 0 (internal symbol) (37) */
  INTS_DIVISION, /**< integer division, division by 0 undefined (user symbol) (38) */
  INTS_DIVISION_TOTAL, /**< integer division with interpreted division by 0 (internal symbol) (39) */
  INTS_MODULUS, /**< integer modulus, division by 0 undefined (user symbol) (40) */
  INTS_MODULUS_TOTAL, /**< integer modulus with interpreted division by 0 (internal symbol) (41) */
  ABS, /**< absolute value (42) */
  DIVISIBLE, /**< divisibility-by-k predicate; first parameter is a DIVISIBLE_OP, second is integer term (43) */
  POW, /**< arithmetic power (44) */
  EXPONENTIAL, /**< exponential (45) */
  SINE, /**< sine (46) */
  COSINE, /**< consine (47) */
  TANGENT, /**< tangent (48) */
  COSECANT, /**< cosecant (49) */
  SECANT, /**< secant (50) */
  COTANGENT, /**< cotangent (51) */
  ARCSINE, /**< arc sine (52) */
  ARCCOSINE, /**< arc consine (53) */
  ARCTANGENT, /**< arc tangent (54) */
  ARCCOSECANT, /**< arc cosecant (55) */
  ARCSECANT, /**< arc secant (56) */
  ARCCOTANGENT, /**< arc cotangent (57) */
  SQRT, /**< square root (58) */
  DIVISIBLE_OP, /**< operator for the divisibility-by-k predicate; payload is an instance of the CVC4::Divisible class (59) */
  CONST_RATIONAL, /**< a multiple-precision rational constant; payload is an instance of the CVC4::Rational class (60) */
  LT, /**< less than, x < y (61) */
  LEQ, /**< less than or equal, x <= y (62) */
  GT, /**< greater than, x > y (63) */
  GEQ, /**< greater than or equal, x >= y (64) */
  INDEXED_ROOT_PREDICATE_OP, /**< operator for the indexed root predicate; payload is an instance of the CVC4::IndexedRootPredicate class (65) */
  INDEXED_ROOT_PREDICATE, /**< indexed root predicate; first parameter is a INDEXED_ROOT_PREDICATE_OP, second is a real variable compared to zero, third is a polynomial (66) */
  IS_INTEGER, /**< term-is-integer predicate (parameter is a real-sorted term) (67) */
  TO_INTEGER, /**< convert term to integer by the floor function (parameter is a real-sorted term) (68) */
  TO_REAL, /**< cast term to real (parameter is an integer-sorted term; this is a no-op in CVC4, as integer is a subtype of real) (69) */
  CAST_TO_REAL, /**< cast term to real same as TO_REAL, but it is used internally, whereas TO_REAL is accessible in the API (70) */
  PI, /**< pi (71) */
  IAND_OP, /**< operator for integer AND; payload is an instance of the CVC4::IntAnd class (72) */
  IAND, /**< integer version of AND operator; first parameter is an IAND_OP, second and third are integer terms (73) */

  /* from bv */
  BITVECTOR_TYPE, /**< bit-vector type (74) */
  CONST_BITVECTOR, /**< a fixed-width bit-vector constant; payload is an instance of the CVC4::BitVector class (75) */
  BITVECTOR_CONCAT, /**< concatenation of two or more bit-vectors (76) */
  BITVECTOR_AND, /**< bitwise and of two or more bit-vectors (77) */
  BITVECTOR_COMP, /**< equality comparison of two bit-vectors (returns one bit) (78) */
  BITVECTOR_OR, /**< bitwise or of two or more bit-vectors (79) */
  BITVECTOR_XOR, /**< bitwise xor of two or more bit-vectors (80) */
  BITVECTOR_NOT, /**< bitwise not of a bit-vector (81) */
  BITVECTOR_NAND, /**< bitwise nand of two bit-vectors (82) */
  BITVECTOR_NOR, /**< bitwise nor of two bit-vectors (83) */
  BITVECTOR_XNOR, /**< bitwise xnor of two bit-vectors (84) */
  BITVECTOR_MULT, /**< multiplication of two or more bit-vectors (85) */
  BITVECTOR_NEG, /**< unary negation of a bit-vector (86) */
  BITVECTOR_PLUS, /**< addition of two or more bit-vectors (87) */
  BITVECTOR_SUB, /**< subtraction of two bit-vectors (88) */
  BITVECTOR_UDIV, /**< unsigned division of two bit-vectors, truncating towards 0 (defined to be the all-ones bit pattern, if divisor is 0) (89) */
  BITVECTOR_UREM, /**< unsigned remainder from truncating division of two bit-vectors (defined to be equal to the dividend, if divisor is 0) (90) */
  BITVECTOR_SDIV, /**< 2's complement signed division (91) */
  BITVECTOR_SMOD, /**< 2's complement signed remainder (sign follows divisor) (92) */
  BITVECTOR_SREM, /**< 2's complement signed remainder (sign follows dividend) (93) */
  BITVECTOR_ASHR, /**< bit-vector arithmetic shift right (the two bit-vector parameters must have same width) (94) */
  BITVECTOR_LSHR, /**< bit-vector logical shift right (the two bit-vector parameters must have same width) (95) */
  BITVECTOR_SHL, /**< bit-vector shift left (the two bit-vector parameters must have same width) (96) */
  BITVECTOR_ULE, /**< bit-vector unsigned less than or equal (the two bit-vector parameters must have same width) (97) */
  BITVECTOR_ULT, /**< bit-vector unsigned less than (the two bit-vector parameters must have same width) (98) */
  BITVECTOR_UGE, /**< bit-vector unsigned greater than or equal (the two bit-vector parameters must have same width) (99) */
  BITVECTOR_UGT, /**< bit-vector unsigned greater than (the two bit-vector parameters must have same width) (100) */
  BITVECTOR_SLE, /**< bit-vector signed less than or equal (the two bit-vector parameters must have same width) (101) */
  BITVECTOR_SLT, /**< bit-vector signed less than (the two bit-vector parameters must have same width) (102) */
  BITVECTOR_SGE, /**< bit-vector signed greater than or equal (the two bit-vector parameters must have same width) (103) */
  BITVECTOR_SGT, /**< bit-vector signed greater than (the two bit-vector parameters must have same width) (104) */
  BITVECTOR_ULTBV, /**< bit-vector unsigned less than but returns bv of size 1 instead of boolean (105) */
  BITVECTOR_SLTBV, /**< bit-vector signed less than but returns bv of size 1 instead of boolean (106) */
  BITVECTOR_REDAND, /**< bit-vector redand (107) */
  BITVECTOR_REDOR, /**< bit-vector redor (108) */
  BITVECTOR_ITE, /**< same semantics as regular ITE, but condition is bv of size 1 instead of Boolean (109) */
  BITVECTOR_TO_NAT, /**< bit-vector conversion to (nonnegative) integer; parameter is a bit-vector (110) */
  BITVECTOR_ACKERMANNIZE_UDIV, /**< term to be treated as a variable; used for eager bit-blasting Ackermann expansion of bvudiv (internal-only symbol) (111) */
  BITVECTOR_ACKERMANNIZE_UREM, /**< term to be treated as a variable; used for eager bit-blasting Ackermann expansion of bvurem (internal-only symbol) (112) */
  BITVECTOR_EAGER_ATOM, /**< formula to be treated as a bv atom via eager bit-blasting (internal-only symbol) (113) */
  BITVECTOR_BITOF_OP, /**< operator for the bit-vector boolean bit extract; payload is an instance of the CVC4::BitVectorBitOf class (114) */
  BITVECTOR_BITOF, /**< bit-vector boolean bit extract; first parameter is a BITVECTOR_BITOF_OP, second is a bit-vector term (115) */
  BITVECTOR_EXTRACT_OP, /**< operator for the bit-vector extract; payload is an instance of the CVC4::BitVectorExtract class (116) */
  BITVECTOR_EXTRACT, /**< bit-vector extract; first parameter is a BITVECTOR_EXTRACT_OP, second is a bit-vector term (117) */
  BITVECTOR_REPEAT_OP, /**< operator for the bit-vector repeat; payload is an instance of the CVC4::BitVectorRepeat class (118) */
  BITVECTOR_REPEAT, /**< bit-vector repeat; first parameter is a BITVECTOR_REPEAT_OP, second is a bit-vector term (119) */
  BITVECTOR_ROTATE_LEFT_OP, /**< operator for the bit-vector rotate left; payload is an instance of the CVC4::BitVectorRotateLeft class (120) */
  BITVECTOR_ROTATE_LEFT, /**< bit-vector rotate left; first parameter is a BITVECTOR_ROTATE_LEFT_OP, second is a bit-vector term (121) */
  BITVECTOR_ROTATE_RIGHT_OP, /**< operator for the bit-vector rotate right; payload is an instance of the CVC4::BitVectorRotateRight class (122) */
  BITVECTOR_ROTATE_RIGHT, /**< bit-vector rotate right; first parameter is a BITVECTOR_ROTATE_RIGHT_OP, second is a bit-vector term (123) */
  BITVECTOR_SIGN_EXTEND_OP, /**< operator for the bit-vector sign-extend; payload is an instance of the CVC4::BitVectorSignExtend class (124) */
  BITVECTOR_SIGN_EXTEND, /**< bit-vector sign-extend; first parameter is a BITVECTOR_SIGN_EXTEND_OP, second is a bit-vector term (125) */
  BITVECTOR_ZERO_EXTEND_OP, /**< operator for the bit-vector zero-extend; payload is an instance of the CVC4::BitVectorZeroExtend class (126) */
  BITVECTOR_ZERO_EXTEND, /**< bit-vector zero-extend; first parameter is a BITVECTOR_ZERO_EXTEND_OP, second is a bit-vector term (127) */
  INT_TO_BITVECTOR_OP, /**< operator for the integer conversion to bit-vector; payload is an instance of the CVC4::IntToBitVector class (128) */
  INT_TO_BITVECTOR, /**< integer conversion to bit-vector; first parameter is an INT_TO_BITVECTOR_OP, second is an integer term (129) */

  /* from fp */
  CONST_FLOATINGPOINT, /**< a floating-point literal (130) */
  CONST_ROUNDINGMODE, /**< a floating-point rounding mode (131) */
  FLOATINGPOINT_TYPE, /**< floating-point type (132) */
  FLOATINGPOINT_FP, /**< construct a floating-point literal from bit vectors (133) */
  FLOATINGPOINT_EQ, /**< floating-point equality (134) */
  FLOATINGPOINT_ABS, /**< floating-point absolute value (135) */
  FLOATINGPOINT_NEG, /**< floating-point negation (136) */
  FLOATINGPOINT_PLUS, /**< floating-point addition (137) */
  FLOATINGPOINT_SUB, /**< floating-point sutraction (138) */
  FLOATINGPOINT_MULT, /**< floating-point multiply (139) */
  FLOATINGPOINT_DIV, /**< floating-point division (140) */
  FLOATINGPOINT_FMA, /**< floating-point fused multiply and add (141) */
  FLOATINGPOINT_SQRT, /**< floating-point square root (142) */
  FLOATINGPOINT_REM, /**< floating-point remainder (143) */
  FLOATINGPOINT_RTI, /**< floating-point round to integral (144) */
  FLOATINGPOINT_MIN, /**< floating-point minimum (145) */
  FLOATINGPOINT_MAX, /**< floating-point maximum (146) */
  FLOATINGPOINT_MIN_TOTAL, /**< floating-point minimum (defined for all inputs) (147) */
  FLOATINGPOINT_MAX_TOTAL, /**< floating-point maximum (defined for all inputs) (148) */
  FLOATINGPOINT_LEQ, /**< floating-point less than or equal (149) */
  FLOATINGPOINT_LT, /**< floating-point less than (150) */
  FLOATINGPOINT_GEQ, /**< floating-point greater than or equal (151) */
  FLOATINGPOINT_GT, /**< floating-point greater than (152) */
  FLOATINGPOINT_ISN, /**< floating-point is normal (153) */
  FLOATINGPOINT_ISSN, /**< floating-point is sub-normal (154) */
  FLOATINGPOINT_ISZ, /**< floating-point is zero (155) */
  FLOATINGPOINT_ISINF, /**< floating-point is infinite (156) */
  FLOATINGPOINT_ISNAN, /**< floating-point is NaN (157) */
  FLOATINGPOINT_ISNEG, /**< floating-point is negative (158) */
  FLOATINGPOINT_ISPOS, /**< floating-point is positive (159) */
  FLOATINGPOINT_TO_FP_IEEE_BITVECTOR_OP, /**< operator for to_fp from bit vector (160) */
  FLOATINGPOINT_TO_FP_IEEE_BITVECTOR, /**< convert an IEEE-754 bit vector to floating-point (161) */
  FLOATINGPOINT_TO_FP_FLOATINGPOINT_OP, /**< operator for to_fp from floating point (162) */
  FLOATINGPOINT_TO_FP_FLOATINGPOINT, /**< convert between floating-point sorts (163) */
  FLOATINGPOINT_TO_FP_REAL_OP, /**< operator for to_fp from real (164) */
  FLOATINGPOINT_TO_FP_REAL, /**< convert a real to floating-point (165) */
  FLOATINGPOINT_TO_FP_SIGNED_BITVECTOR_OP, /**< operator for to_fp from signed bit vector (166) */
  FLOATINGPOINT_TO_FP_SIGNED_BITVECTOR, /**< convert a signed bit vector to floating-point (167) */
  FLOATINGPOINT_TO_FP_UNSIGNED_BITVECTOR_OP, /**< operator for to_fp from unsigned bit vector (168) */
  FLOATINGPOINT_TO_FP_UNSIGNED_BITVECTOR, /**< convert an unsigned bit vector to floating-point (169) */
  FLOATINGPOINT_TO_FP_GENERIC_OP, /**< operator for a generic to_fp (170) */
  FLOATINGPOINT_TO_FP_GENERIC, /**< a generic conversion to floating-point, used in parsing only (171) */
  FLOATINGPOINT_TO_UBV_OP, /**< operator for to_ubv (172) */
  FLOATINGPOINT_TO_UBV, /**< convert a floating-point value to an unsigned bit vector (173) */
  FLOATINGPOINT_TO_UBV_TOTAL_OP, /**< operator for to_ubv_total (174) */
  FLOATINGPOINT_TO_UBV_TOTAL, /**< convert a floating-point value to an unsigned bit vector (defined for all inputs) (175) */
  FLOATINGPOINT_TO_SBV_OP, /**< operator for to_sbv (176) */
  FLOATINGPOINT_TO_SBV, /**< convert a floating-point value to a signed bit vector (177) */
  FLOATINGPOINT_TO_SBV_TOTAL_OP, /**< operator for to_sbv_total (178) */
  FLOATINGPOINT_TO_SBV_TOTAL, /**< convert a floating-point value to a signed bit vector (defined for all inputs) (179) */
  FLOATINGPOINT_TO_REAL, /**< floating-point to real (180) */
  FLOATINGPOINT_TO_REAL_TOTAL, /**< floating-point to real (defined for all inputs) (181) */
  FLOATINGPOINT_COMPONENT_NAN, /**< NaN component of a word-blasted floating-point number (182) */
  FLOATINGPOINT_COMPONENT_INF, /**< Inf component of a word-blasted floating-point number (183) */
  FLOATINGPOINT_COMPONENT_ZERO, /**< Zero component of a word-blasted floating-point number (184) */
  FLOATINGPOINT_COMPONENT_SIGN, /**< Sign component of a word-blasted floating-point number (185) */
  FLOATINGPOINT_COMPONENT_EXPONENT, /**< Exponent component of a word-blasted floating-point number (186) */
  FLOATINGPOINT_COMPONENT_SIGNIFICAND, /**< Significand component of a word-blasted floating-point number (187) */
  ROUNDINGMODE_BITBLAST, /**< The bit-vector for a non-deterministic rounding mode (188) */

  /* from arrays */
  ARRAY_TYPE, /**< array type (189) */
  SELECT, /**< array select; first parameter is an array term, second is the selection index (190) */
  STORE, /**< array store; first parameter is an array term, second is the store index, third is the term to store at the index (191) */
  EQ_RANGE, /**< equality of two arrays over an index range lower/upper (192) */
  STORE_ALL, /**< array store-all; payload is an instance of the CVC4::ArrayStoreAll class (this is not supported by arrays decision procedure yet, but it is used for returned array models) (193) */
  ARR_TABLE_FUN, /**< array table function (internal-only symbol) (194) */
  ARRAY_LAMBDA, /**< array lambda (internal-only symbol) (195) */
  PARTIAL_SELECT_0, /**< partial array select, for internal use only (196) */
  PARTIAL_SELECT_1, /**< partial array select, for internal use only (197) */

  /* from datatypes */
  CONSTRUCTOR_TYPE, /**< constructor (198) */
  SELECTOR_TYPE, /**< selector (199) */
  TESTER_TYPE, /**< tester (200) */
  APPLY_CONSTRUCTOR, /**< constructor application; first parameter is the constructor, remaining parameters (if any) are parameters to the constructor (201) */
  APPLY_SELECTOR, /**< selector application; parameter is a datatype term (undefined if mis-applied) (202) */
  APPLY_SELECTOR_TOTAL, /**< selector application; parameter is a datatype term (defined rigidly if mis-applied) (203) */
  APPLY_TESTER, /**< tester application; first parameter is a tester, second is a datatype term (204) */
  DATATYPE_TYPE, /**< a datatype type index (205) */
  PARAMETRIC_DATATYPE, /**< parametric datatype (206) */
  APPLY_TYPE_ASCRIPTION, /**< type ascription, for datatype constructor applications; first parameter is an ASCRIPTION_TYPE, second is the datatype constructor application being ascribed (207) */
  ASCRIPTION_TYPE, /**< a type parameter for type ascription; payload is an instance of the CVC4::AscriptionType class (208) */
  TUPLE_UPDATE_OP, /**< operator for a tuple update; payload is an instance of the CVC4::TupleUpdate class (209) */
  TUPLE_UPDATE, /**< tuple update; first parameter is a TUPLE_UPDATE_OP (which references an index), second is the tuple, third is the element to store in the tuple at the given index (210) */
  RECORD_UPDATE_OP, /**< operator for a record update; payload is an instance CVC4::RecordUpdate class (211) */
  RECORD_UPDATE, /**< record update; first parameter is a RECORD_UPDATE_OP (which references a field), second is a record term to update, third is the element to store in the record in the given field (212) */
  DT_SIZE, /**< datatypes size (213) */
  DT_HEIGHT_BOUND, /**< datatypes height bound (214) */
  DT_SIZE_BOUND, /**< datatypes height bound (215) */
  DT_SYGUS_BOUND, /**< datatypes sygus bound (216) */
  DT_SYGUS_EVAL, /**< datatypes sygus evaluation function (217) */
  MATCH, /**< match construct (218) */
  MATCH_CASE, /**< a match case (219) */
  MATCH_BIND_CASE, /**< a match case with bound variables (220) */
  TUPLE_PROJECT_OP, /**< operator for TUPLE_PROJECT; payload is an instance of the CVC4::TupleProjectOp class (221) */
  TUPLE_PROJECT, /**< projects a tuple from an existing tuple using indices passed in TupleProjectOp (222) */

  /* from sep */
  SEP_NIL, /**< separation nil (223) */
  SEP_EMP, /**< separation empty heap (224) */
  SEP_PTO, /**< points to relation (225) */
  SEP_STAR, /**< separation star (226) */
  SEP_WAND, /**< separation magic wand (227) */
  SEP_LABEL, /**< separation label (internal use only) (228) */

  /* from sets */
  EMPTYSET, /**< the empty set constant; payload is an instance of the CVC4::EmptySet class (229) */
  SET_TYPE, /**< set type, takes as parameter the type of the elements (230) */
  UNION, /**< set union (231) */
  INTERSECTION, /**< set intersection (232) */
  SETMINUS, /**< set subtraction (233) */
  SUBSET, /**< subset predicate; first parameter a subset of second (234) */
  MEMBER, /**< set membership predicate; first parameter a member of second (235) */
  SINGLETON_OP, /**< operator for singletons; payload is an instance of the CVC4::SingletonOp class (236) */
  SINGLETON, /**< constructs a set of a single element. First parameter is a SingletonOp. Second is a term (237) */
  INSERT, /**< set obtained by inserting elements (first N-1 parameters) into a set (the last parameter) (238) */
  CARD, /**< set cardinality operator (239) */
  COMPLEMENT, /**< set COMPLEMENT (with respect to finite universe) (240) */
  UNIVERSE_SET, /**< (finite) universe set, all set variables must be interpreted as subsets of it. (241) */
  COMPREHENSION, /**< set comprehension specified by a bound variable list, a predicate, and a term. (242) */
  CHOOSE, /**< return an element in the set given as a parameter (243) */
  IS_SINGLETON, /**< return whether the given set is a singleton (244) */
  JOIN, /**< set join (245) */
  PRODUCT, /**< set cartesian product (246) */
  TRANSPOSE, /**< set transpose (247) */
  TCLOSURE, /**< set transitive closure (248) */
  JOIN_IMAGE, /**< set join image (249) */
  IDEN, /**< set identity (250) */

  /* from bags */
  EMPTYBAG, /**< the empty bag constant; payload is an instance of the CVC4::EmptyBag class (251) */
  BAG_TYPE, /**< bag type, takes as parameter the type of the elements (252) */
  UNION_MAX, /**< union for bags (max) (253) */
  UNION_DISJOINT, /**< disjoint union for bags (sum) (254) */
  INTERSECTION_MIN, /**< bag intersection (min) (255) */
  DIFFERENCE_SUBTRACT, /**< bag difference1 (subtracts multiplicities) (256) */
  DIFFERENCE_REMOVE, /**< bag difference remove (removes shared elements) (257) */
  SUBBAG, /**< inclusion predicate for bags (less than or equal multiplicities) (258) */
  BAG_COUNT, /**< multiplicity of an element in a bag (259) */
  DUPLICATE_REMOVAL, /**< eliminate duplicates in a bag (also known as the delta operator,or the squash operator) (260) */
  MK_BAG_OP, /**< operator for MK_BAG; payload is an instance of the CVC4::MakeBagOp class (261) */
  MK_BAG, /**< constructs a bag from one element along with its multiplicity (262) */
  BAG_IS_SINGLETON, /**< return whether the given bag is a singleton (263) */
  BAG_CARD, /**< bag cardinality operator (264) */
  BAG_FROM_SET, /**< converts a set to a bag (265) */
  BAG_TO_SET, /**< converts a bag to a set (266) */
  BAG_CHOOSE, /**< return an element in the bag given as a parameter (267) */

  /* from strings */
  STRING_CONCAT, /**< string concat (N-ary) (268) */
  STRING_IN_REGEXP, /**< membership (269) */
  STRING_LENGTH, /**< string length (270) */
  STRING_SUBSTR, /**< string substr (271) */
  STRING_UPDATE, /**< string update (272) */
  STRING_CHARAT, /**< string charat (273) */
  STRING_STRCTN, /**< string contains (274) */
  STRING_LT, /**< string less than (275) */
  STRING_LEQ, /**< string less than or equal (276) */
  STRING_STRIDOF, /**< string indexof (277) */
  STRING_STRREPL, /**< string replace (278) */
  STRING_STRREPLALL, /**< string replace all (279) */
  STRING_REPLACE_RE, /**< string replace regular expression match (280) */
  STRING_REPLACE_RE_ALL, /**< string replace all regular expression matches (281) */
  STRING_PREFIX, /**< string prefixof (282) */
  STRING_SUFFIX, /**< string suffixof (283) */
  STRING_IS_DIGIT, /**< string isdigit, returns true if argument is a string of length one that represents a digit (284) */
  STRING_ITOS, /**< integer to string (285) */
  STRING_STOI, /**< string to integer (total function) (286) */
  STRING_TO_CODE, /**< string to code, returns the code of the first character of the string if it has length one, -1 otherwise (287) */
  STRING_FROM_CODE, /**< string from code, returns a string containing a single character whose code point matches the argument to this function, empty string if the argument is out-of-bounds (288) */
  STRING_TOLOWER, /**< string to lowercase conversion (289) */
  STRING_TOUPPER, /**< string to uppercase conversion (290) */
  STRING_REV, /**< string reverse (291) */
  CONST_STRING, /**< a string of characters (292) */
  SEQUENCE_TYPE, /**< seuence type, takes as parameter the type of the elements (293) */
  CONST_SEQUENCE, /**< a sequence of characters (294) */
  SEQ_UNIT, /**< a sequence of length one (295) */
  SEQ_NTH, /**< The nth element of a sequence (296) */
  SEQ_NTH_TOTAL, /**< The nth element of a sequence (internal, for responses to expand definitions only) (297) */
  STRING_TO_REGEXP, /**< convert string to regexp (298) */
  REGEXP_CONCAT, /**< regexp concat (299) */
  REGEXP_UNION, /**< regexp union (300) */
  REGEXP_INTER, /**< regexp intersection (301) */
  REGEXP_DIFF, /**< regexp difference (302) */
  REGEXP_STAR, /**< regexp * (303) */
  REGEXP_PLUS, /**< regexp + (304) */
  REGEXP_OPT, /**< regexp ? (305) */
  REGEXP_RANGE, /**< regexp range (306) */
  REGEXP_COMPLEMENT, /**< regexp complement (307) */
  REGEXP_EMPTY, /**< regexp empty (308) */
  REGEXP_SIGMA, /**< regexp all characters (309) */
  REGEXP_REPEAT_OP, /**< operator for regular expression repeat; payload is an instance of the CVC4::RegExpRepeat class (310) */
  REGEXP_REPEAT, /**< regular expression repeat; first parameter is a REGEXP_REPEAT_OP, second is a regular expression term (311) */
  REGEXP_LOOP_OP, /**< operator for regular expression loop; payload is an instance of the CVC4::RegExpLoop class (312) */
  REGEXP_LOOP, /**< regular expression loop; first parameter is a REGEXP_LOOP_OP, second is a regular expression term (313) */
  REGEXP_RV, /**< regexp rv (internal use only) (314) */

  /* from quantifiers */
  FORALL, /**< universally quantified formula; first parameter is an BOUND_VAR_LIST, second is quantifier body, and an optional third parameter is an INST_PATTERN_LIST (315) */
  EXISTS, /**< existentially quantified formula; first parameter is an BOUND_VAR_LIST, second is quantifier body, and an optional third parameter is an INST_PATTERN_LIST (316) */
  INST_CONSTANT, /**< instantiation constant (317) */
  BOUND_VAR_LIST, /**< a list of bound variables (used to bind variables under a quantifier) (318) */
  INST_PATTERN, /**< instantiation pattern (319) */
  INST_NO_PATTERN, /**< instantiation no-pattern (320) */
  INST_ATTRIBUTE, /**< instantiation attribute (321) */
  INST_PATTERN_LIST, /**< a list of instantiation patterns (322) */

  LAST_KIND /**< marks the upper-bound of this enumeration */

};/* enum Kind_t */

}/* CVC4::kind namespace */

// import Kind into the "CVC4" namespace but keep the individual kind
// constants under kind::
typedef ::CVC4::kind::Kind_t Kind;

namespace kind {

/**
 * Converts an kind to a string. Note: This function is also used in
 * `safe_print()`. Changing this functions name or signature will result in
 * `safe_print()` printing "<unsupported>" instead of the proper strings for
 * the enum values.
 *
 * @param k The kind
 * @return The name of the kind
 */
const char* toString(CVC4::Kind k);

/**
 * Writes a kind name to a stream.
 *
 * @param out The stream to write to
 * @param k The kind to write to the stream
 * @return The stream
 */
std::ostream& operator<<(std::ostream&, CVC4::Kind) CVC4_PUBLIC;

/** Returns true if the given kind is associative. This is used by ExprManager to
 * decide whether it's safe to modify big expressions by changing the grouping of
 * the arguments. */
/* TODO: This could be generated. */
bool isAssociative(::CVC4::Kind k) CVC4_PUBLIC;
std::string kindToString(::CVC4::Kind k) CVC4_PUBLIC;

struct KindHashFunction {
  inline size_t operator()(::CVC4::Kind k) const {
    return k;
  }
};/* struct KindHashFunction */

}/* CVC4::kind namespace */

/**
 * The enumeration for the built-in atomic types.
 */
enum CVC4_PUBLIC TypeConstant
{
    BUILTIN_OPERATOR_TYPE, /**< the type for built-in operators */
  BOOLEAN_TYPE, /**< Boolean type */
  REAL_TYPE, /**< real type */
  INTEGER_TYPE, /**< integer type */
  ROUNDINGMODE_TYPE, /**< floating-point rounding mode */
  STRING_TYPE, /**< String type */
  REGEXP_TYPE, /**< RegExp type */
  BOUND_VAR_LIST_TYPE, /**< the type of bound variable lists */
  INST_PATTERN_TYPE, /**< instantiation pattern type */
  INST_PATTERN_LIST_TYPE, /**< the type of instantiation pattern lists */

  LAST_TYPE
}; /* enum TypeConstant */

/**
 * We hash the constants with their values.
 */
struct TypeConstantHashFunction {
  inline size_t operator()(TypeConstant tc) const {
    return tc;
  }
};/* struct TypeConstantHashFunction */

std::ostream& operator<<(std::ostream& out, TypeConstant typeConstant);

namespace theory {

::CVC4::theory::TheoryId kindToTheoryId(::CVC4::Kind k) CVC4_PUBLIC;
::CVC4::theory::TheoryId typeConstantToTheoryId(
    ::CVC4::TypeConstant typeConstant) CVC4_PUBLIC;

}/* CVC4::theory namespace */
}/* CVC4 namespace */

#endif /* CVC4__KIND_H */
